// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "ARTraceResult.h"
#include "GameFramework/GameModeBase.h"
#include "CustomGameMode.generated.h"

//Forward Declarations
class APlaceableActor;
class AGameplayPlane;
class AFishingPond;
class AHelloARManager;
class UCustomUserWidget;
class USoundBase;

//! @brief Enumerator specifying the different game states
UENUM()
enum EDisplayMode
{
	Intro UMETA(DisplayName = "Intro"),
	Default UMETA(DisplayName = "Default"),
	Fishing UMETA(DisplayName = "Fishing")
};

//! @brief Structure encapsulating the layout data to be saved
USTRUCT()
struct FLayoutData
{
	GENERATED_BODY()

	//! The actor class of the object
	TSubclassOf<APlaceableActor> Class;

	//! The pin relative transform
	FTransform GeneralRelativeTransform;

	//! The base static mesh specific transform 
	FTransform StaticMeshTransform;
};

//! @brief Class governing the application and holder of the global data
UCLASS()
class UE5_AR_API ACustomGameMode : public AGameModeBase
{
	GENERATED_BODY()

public:

	ACustomGameMode();
	virtual ~ACustomGameMode() = default;

	//! @brief Function called at the start of the level/game
	virtual void StartPlay() override;

	//! @brief Called every frame
	//! @param DeltaTime - time difference between frames.
	virtual void Tick(float DeltaSeconds) override;

	// Functions

	//! @brief Function called to start the game
	//! Starts the AR manager with AR session
	void StartGame();

	//! @brief Function overrideable in blueprints, called at the start of the game.
	UFUNCTION(BlueprintNativeEvent, Category = "GameModeBase", DisplayName = "Start Play")
		void StartPlayEvent();

	//! @brief Function that returns the stored amount of money form game state
	//! @returns [value] - Player's balance.
	UFUNCTION(BlueprintCallable, Category = "Money")
		int32 GetMoney() const;

	//! @brief Function that sets the Player's balance.
	//! @param NewMoney - New player's balance.
	UFUNCTION(BlueprintCallable, Category = "Money")
		void SetMoney(const int32 NewMoney);

	//! @brief Function that adds a given amount to the player's balance
	//! @param AddMoney - The amount of money to add.
	UFUNCTION(BlueprintCallable, Category = "Money")
		void AddMoney(const int32 AddMoney);

	//! @brief Function that changes the game state to the provided one.
	//! Iterates through spawned placeable actors and calls the relevant event.
	//! @param NewMode - The mode the application is to switch to.
	UFUNCTION(BlueprintCallable, Category = "Display Mode")
		void SetDisplayType(const TEnumAsByte<EDisplayMode> NewMode);

	//! @brief Function returning the current state.
	//! @returns [value] - The current game state.
	UFUNCTION(BlueprintCallable, Category = "Display Mode")
		TEnumAsByte<EDisplayMode> GetDisplayType() { return DisplayType; };

	//! @brief Function returning the pointer to the currently spawned gameplay plane
	//! Type of the plane is not specified.
	//! @returns [value] - Currently spawned gameplay, plane if any.
	//! @returns nullptr - otherwise.
	UFUNCTION(BlueprintCallable, Category = "Game State")
		AGameplayPlane* GetGameplayPlane() const { return SpawnedPlane; }

	//! @brief Function returning the currently shown major UI screen.
	//! @returns [value] - currently spawned major UI screen.
	UFUNCTION(BlueprintCallable, Category = "Game State")
		UCustomUserWidget* GetCurrentUI() const { return CurrentUI; }

	//! @brief Function informing whether the Ar plane on which the Pin is is determined
	//! @returns true - If the AR Pin and plane are determined.
	//! @returns false - otherwise.
	UFUNCTION(BlueprintCallable, Category = "Game State")
		bool IsDeterminedPlane() const { return bPlaneDetermined; }

	//! @brief Function used to specify the actor that was selected by the player.
	//! nullptr input will clean the pointer, will call deselect if possible
	//! @param SelectedObj - Actor that was selected.
	UFUNCTION(BlueprintCallable, Category = "Game State")
		void SetSelectedActor(APlaceableActor* SelectedObj);

	//! @brief Function to access the currently selected actor.
	//! @returns [value] - The pointer to the selected actor, if any.
	//! @returns nullptr - otherwise.
	UFUNCTION(BlueprintCallable, Category = "Game State")
		APlaceableActor* GetSelectedActor() const { return SelectedObject; }

	//! @brief Function performing a specific line trace
	//! Traces for both the AR planes and Pawn objects
	//! @param ScreenPos - The position of the touch in screen-space.
	//! @param TraceResults - [OUT] Array of all the AR plane hits that generated by the traced line.
	//! @param TraceResultObj - [OUT] First hit actor hit by the traced line.
	//! @param DirectionResult - [OUT] Direction of the traced line.
	UFUNCTION(BlueprintCallable, Category = "Game Functionality")
		void AskForLineTrace(const FVector& ScreenPos, TArray<FARTraceResult>& TraceResults, FHitResult& TraceResultObj, FVector& DirectionResult);

	//! @brief Function to spawn a relevant gameplay plane at a given line trace result.
	//! @param LineTraceHit - Validated AR line trace hit result.
	//! @param Direction - Direction of the line trace.
	UFUNCTION(BlueprintCallable, Category = "Game Functionality")
		void AskForLineTraceSpawnActor(const FARTraceResult& LineTraceHit, const FVector& Direction);

	//! @brief Function to store the layout array to be preserved between states.
	//! Overwrites any previously kept layout data.
	//! @param LayoutData - The layout array to be preserved.
	UFUNCTION(Category = "Game Functionality")
		void StoreLayoutData(TArray<FLayoutData> &LayoutData);

	//! @brief Function returning a reference to the stored layout data.
	//! @returns [value] - The stored layout array.
	UFUNCTION(Category = "Game Functionality")
		TArray<FLayoutData>& GetLayoutData() { return StoredLayoutData; };

	//! @brief Last resort touch input resolving function.
	//! @param LineTraceHit - Validated AR line trace hit result.
	//! @param Direction - Direction of the line trace.
	virtual void HandleGeneralLineTraceResult(const FARTraceResult& LineTraceHit, const FVector& Direction);

	// Assets

	//! Map associating the gameplay plane class to spawn with the gameplay state
	UPROPERTY(Category = "State associations", EditAnywhere, BlueprintReadWrite)
		TMap<TEnumAsByte<EDisplayMode>, TSubclassOf<AGameplayPlane>> GameplayPlanes;

	//! Map associating the major UI with the gameplay state
	UPROPERTY(Category = "State associations", EditAnywhere, BlueprintReadWrite)
		TMap<TEnumAsByte<EDisplayMode>, TSubclassOf<UCustomUserWidget>> UIScreens;

	//! The sound "bank" asset for the SFX to be played at successful gameplay plane spawn
	UPROPERTY(Category = "Audio", EditAnywhere, BlueprintReadWrite)
		USoundBase* PlaneSpawnSfx;

	// Constants

	//! Maximum distance for line trace, world units
	UPROPERTY(Category = "Settings", EditAnywhere, BlueprintReadWrite)
		float ObjectLineTraceDistance = 1000.0f;

protected:

	//Hidden

	//! Flag noting whether the AR plane and AR Pin have been determined
	bool bPlaneDetermined = false;

	//! Pointer ot the ONLY AR manager
	AHelloARManager* ArManager;

	//! Game state tracker
	TEnumAsByte<EDisplayMode> DisplayType = Intro;

	//Hidden properties

	//! The spawned gameplay plane, can be nullptr
	UPROPERTY()
		AGameplayPlane* SpawnedPlane = nullptr;

	//! The currently selected object by the player, can be nullptr
	UPROPERTY()
		APlaceableActor* SelectedObject = nullptr;

	//! The currently shown major UI instance 
	UPROPERTY()
		UCustomUserWidget* CurrentUI = nullptr;

	//! The preserved house layout
	UPROPERTY()
		TArray<FLayoutData> StoredLayoutData = {};
};
